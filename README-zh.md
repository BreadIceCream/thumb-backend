
# **👍 BreadThumb \- 高性能点赞服务系统**

本项目是一个高性能的后端服务，旨在处理类似于 Twitter 或抖音等平台的“点赞”功能。它基于 Spring Boot 构建，并采用了一套包含 Redis、消息队列 (Pulsar) 和多种缓存策略的复杂架构，以确保在高负载下系统仍能保持高可用性、数据一致性和实时响应能力。

该系统通过三个主要的实现阶段演进，展示了处理高并发场景的不同架构方法：

1. **1️⃣ 纯数据库方案:** 基础实现，所有点赞/取消点赞操作直接读写 MySQL 数据库。
2. **2️⃣ Redis \+ 定时任务方案:** 优化版本，使用 Redis 缓存点赞数据，并通过定时任务周期性地将数据同步回数据库。
3. **3️⃣ Redis \+ 消息队列方案:** 最稳健的实现，使用 Redis 完成初始操作，并通过消息队列 (Pulsar) 异步地将数据持久化到数据库，确保了数据的持久性和系统解耦。

## **🏛️ 架构概览**

该系统基于微服务友好型架构，利用多种关键技术来实现其核心目标。

### **核心技术**

* 🍃 **框架:** Spring Boot 3
* 🐬 **数据库:** MySQL
* ⚡ **内存缓存:** Redis (用于缓存用户点赞、热点帖子和临时数据)
* ☕ **本地缓存:** Caffeine (用于内存中缓存频繁访问的博客文章)
* 📬 **消息队列:** Apache Pulsar (用于异步处理点赞/取消点赞事件)
* 🗺️ **ORM:** MyBatis-Plus
* 🔥 **热点内容发现:** HeavyKeeper 算法用于识别热门帖子。
* 📄 **数据导出:** EasyExcel 用于处理数据导出（例如从死信队列导出）。

### **项目结构**

项目采用标准的 Maven 目录结构，包含以下关键包：

* 🎮 controller: 处理用户的博客和点赞相关的 HTTP 请求。
* 🛠️ service: 包含核心业务逻辑。其中包含了 ThumbService 的多种实现，以代表不同的架构阶段。
* 🔗 mapper: 定义 MyBatis 的数据库接口。
* 📦 model: 包括实体类（数据库表）、DTO（数据传输对象）和 VO（视图对象）。
* 📨 mq: 包含消息队列的消费者和事件定义。
* ⏰ job: 存放用于将数据从 Redis 同步到数据库的定时任务。
* ⚙️ config: Redis、MyBatis、Pulsar 的配置以及全局异常处理。
* 🔧 util: 工具类，包括 BlogCacheManager 和 Redis 键的辅助类。
* 🧱 common: 通用类，如 HeavyKeeper 算法的实现和标准化的 API 响应格式。

## **🧠 核心业务逻辑与实现**

### **👍 1\. 点赞/取消点赞功能**

系统的核心功能是能够对博客文章进行点赞或取消点赞。项目为此过程提供了三种不同的实现，每种实现都有其自身的权衡。

#### **ThumbServiceMQImpl (Redis \+ 消息队列) \- ✅ 推荐方案**

这是最先进且最具弹性的实现。当用户点赞一篇文章时：

1. **Redis 原子操作:** 在 Redis 服务器上执行一个 Lua 脚本以确保原子性。该脚本会检查用户是否已经点赞过该文章。如果没有，它会将用户的 ID 添加到一个与该用户点赞相关的 Redis Hash 中，并对 Redis 中缓存的“热点”文章的点赞数进行递增。
2. **消息生产:** 一个事件 (例如 THUMB\_INCR) 被发送到 Apache Pulsar 的一个主题中。此消息包含 userId、blogId 和事件的时间戳。
3. **异步消费:** 一个 Pulsar 消费者监听该主题。在收到消息后，它会进行批量处理，更新 MySQL 数据库中的 thumb 表（插入或删除记录），并更新 blog 表中的 thumbCount。
4. **即时反馈:** 用户会立即收到“点赞”成功的确认，而无需等待数据库写入完成。

**此方法的关键特性:**

* 🚀 **高吞吐量:** 系统能够处理大量的写操作，因为初始请求仅涉及一次快速的 Redis 操作。
* 💪 **弹性:** 如果数据库暂时不可用，消息队列将保留这些事件并在稍后重试处理，从而防止数据丢失。
* 🛡️ **数据一致性:** Pulsar 中的 Key\_Shared 订阅模式确保了同一篇文章的所有事件都由同一个消费者按顺序处理，从而避免了竞态条件。
* 🪦 **死信队列 (DLQ):** 如果一条消息持续处理失败，它将被移至一个死信主题。一个单独的监听器 (consumeDlq) 会处理这些失败的消息，并将它们归档到一个 Excel 文件中以供人工审查。

#### **📜 Lua 脚本保证原子性**

在 Redis 中使用 Lua 脚本至关重要。它允许多个命令在 Redis 服务器上作为单个原子事务执行，从而防止竞态条件。例如，检查用户是否已点赞文章然后添加点赞记录必须在一个步骤中完成。项目包含了诸如 ThumbMQ.lua 和 UnthumbMQ.lua 等脚本来完成这些操作。

### **🔥 2\. 针对热点内容的多级缓存**

为了减少读操作的数据库负载，系统对博客文章采用了多级缓存策略。

#### **BlogCacheManager**

这个工具类管理缓存逻辑：

1. ☕ **本地缓存 (Caffeine):** 一个高速的内存缓存，用于存储最常访问的博客文章。这是系统查找博客文章的第一个地方。
2. ⚡ **远程缓存 (Redis):** 如果文章不在本地缓存中，系统会检查 Redis。Redis 存储了“热点”博客文章——那些最近被频繁点赞或查看的文章。
3. 🐬 **数据库:** 如果在两个缓存中都找不到文章，则从 MySQL 数据库中获取。

#### **🔥 使用 HeavyKeeper 发现热点内容**

系统使用 **HeavyKeeper** 算法来识别哪些博客文章是“热点”或趋势内容。

* HeavyKeeper 是一种概率性算法，可以用最少的内存高效地在海量数据流中找到最频繁的项目。
* 每当访问一篇博客文章时，其 ID 就会被输入到 HeavyKeeper 实例中。
* 一个定时任务 (syncHotBlog2Redis) 会定期查询 HeavyKeeper 以获取排名前 K 的热门文章，并将它们缓存到 Redis 中。这确保了 Redis 缓存中始终填充着最相关的内容，从而提高了读取性能。

### **💾 3\. 数据持久化与同步**

#### **通过消息队列异步持久化**

如上所述，推荐架构中数据持久化的主要方法是通过消息队列。ThumbConsumer 负责批量处理消息并更新数据库。这将写操作与用户请求解耦，并允许优雅地处理数据库负载。

#### **用于数据同步的定时任务 (ThumbServiceRedisImpl)**

在项目中提供的另一种架构中，使用定时任务进行同步。

* **Redis 中的临时数据:** 当用户点赞一篇文章时，点赞信息会存储在一个临时的 Redis Hash 中，该 Hash 以时间片（例如，10秒窗口）为键。
* **周期性同步:** 一个定时任务 (SyncThumb2DBJob) 每 10 秒运行一次。它会从 Redis 中读取前一个时间片的数据。
* **批量数据库更新:** 该任务随后对 MySQL 数据库执行批量更新——插入新的 thumb 记录并更新 blog 表上的 thumbCount。
* **补偿任务:** 一个每日的补偿任务 (SyncThumb2DBCompensatoryJob) 运行以确保任何可能被常规任务遗漏的数据得到处理，从而保证最终一致性。

这种方法比消息队列简单，但对数据库停机的弹性较差，并且可能会在数据持久化方面引入轻微的延迟。

## **🚀 如何开始**

要运行此项目，您需要：

* ☕ Java 21
* 📦 Maven
* 🐬 MySQL
* ⚡ Redis
* 📬 Apache Pulsar

**🔧 配置:**

1. 设置您的 MySQL 数据库，并运行 table-ddl.sql 中定义的 schema。
2. 使用您的数据库、Redis 和 Pulsar 连接详细信息更新 application.yaml 文件。
3. 运行 BreadThumbApplication 主类以启动服务器。